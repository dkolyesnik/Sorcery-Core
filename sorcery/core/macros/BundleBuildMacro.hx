package sorcery.core.macros;
import haxe.macro.Context;
import haxe.macro.Expr.Access;
import haxe.macro.Expr.Field;
import haxe.macro.Expr.FieldType;

/**
 * ...
 * @author Dmitriy Kolesnik
 */
#if macro
class BundleBuildMacro
{
	private static var setupBundleNameMethodName = "setupBundleName";
	public static macro function build():Array<Field>
	{
		var localClassName = Context.getLocalClass().get().name;
		var fields = Context.getBuildFields();
		var nameField;
		var setupMethod;
		for (f in fields)
		{
			if (f.name == "NAME")
				nameField = f;
			else if (f.name == setupBundleNameMethodName)
				setupMethod = f;
		}
		var name:String = localClassName;
		//if has Bundle in class name
		if(name.substr(name.length - 6) == "Bundle")
		{
			name = name.substr(0, name.length - 6);
			if (nameField == null && setupMethod == null)
			{
				nameField = {
					name: "NAME",
					doc:"Generated by build macros",
					access:[Access.AInline, Access.APublic, Access.AStatic],
					kind: FieldType.FVar(macro: String, macro $v{name}),
					pos: Context.currentPos()
				}
				fields.push(nameField);
				
				setupMethod = {
					name:setupBundleNameMethodName,
					access:[Access.AOverride, Access.APrivate],
					kind: FieldType.FFun({
						args:[],
						ret: macro:Void,
						expr: macro this.setName(NAME)
					}),
					pos: Context.currentPos()
				}
				fields.push(setupMethod);
			}
			else
			{
				trace('NAME field or method $setupBundleNameMethodName is found, do not generating field in class $localClassName');
			}
		}
		else
		{
			trace('Wrong bundle class name in $localClassName');
		}
		
		
		return fields;
	}
	
}
#end